import utils.constants as constants

from typing import Union
import os


class InputUtils:
    DEFAULT_FILE_PATH_PREFIX = os.environ[constants.SRC_ROOT] + "outputs/transcripts"

    @classmethod
    def read_file_texts(
        cls, base_path: str | list[str], group_by_batch: bool = False, extension: str = "txt"
    ) -> list[str | list[str]]:
        """
        Reads transcript generated by the run_debate script. All the files are named using the following
        convention: base_path_{round_number}_{batch_number}.txt.

        Params:
            base_path: the directory + file prefix that all the transcripts share. This can be a list if there are multiple
                sets of file prefixes that one wants to aggregate into one dataset
            group_by_batch: whether one wants to have all the transcripts that are part of the same
                batch to be returned together in a list (useful for reading best-of-n transcripts)
            extension: "txt" if the files are txt files or "json"

        Returns:
            file_texts: if group_by_batch is false, this is just a list of transcript contents. If
                group_by_text is true, this is a list of list of transcript contents, where the
                inner lists contain all the transcripts from a single batch.
        """

        def add_batch(current_batch: list[str], file_texts: list[str | list[str]]):
            if current_batch:
                if group_by_batch:
                    file_texts.append([example for example in current_batch])
                else:
                    file_texts += [example for example in current_batch]
                current_batch.clear()

        if isinstance(base_path, list):
            input_texts = []
            for path in base_path:
                input_texts += InputUtils.read_file_texts(base_path=path, group_by_batch=group_by_batch, extension=extension)
            return input_texts

        base_path = base_path if "/" in base_path else "/".join([InputUtils.DEFAULT_FILE_PATH_PREFIX, base_path])

        round_idx = 0
        batch_idx = 0
        keep_extracting = True
        file_texts = []
        current_batch = []
        while keep_extracting:
            candidate_path = f"{base_path}_{round_idx}_{batch_idx}.{extension}"
            if os.path.exists(candidate_path):
                with open(candidate_path) as f:
                    current_batch.append(f.read())
                batch_idx += 1
            elif batch_idx == 0:
                keep_extracting = False
                add_batch(current_batch, file_texts)
            else:
                round_idx += 1
                batch_idx = 0
                add_batch(current_batch, file_texts)
        return file_texts
