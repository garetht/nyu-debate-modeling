from __future__ import annotations

from agents.models import ModelInput
from prompts import Prompt, PromptTag, RoleType
import utils.constants as constants

from pydantic import BaseModel

from enum import Enum
from typing import Any, Callable, Optional, Union
import copy
import json


class Speech(BaseModel):
    speaker: str
    content: str


class SpeechType(Enum):
    PRE_FILLED = 1
    USER_INPUTTED = 2


class SpeechFormatEntry(BaseModel):
    speech_type: SpeechType
    prompt_tag: Optional[PromptTag]
    last_only_prompt_tag: Optional[PromptTag]
    expected_speaker: Optional[str]


class SpeechFormat:
    def __init__(self, name: str):
        """
        A structure corresponding to the order of speeches and prompts that are expected to be delivered.

        Params:
            name: The name of the debater who is using this structure.
        """
        self.progression = []
        self.name = name

    def add(
        self,
        speech_type: Optional[SpeechType] = None,
        prompt_tag: Optional[PromptTag] = None,
        last_only_prompt_tag: Optional[PromptTag] = None,
        expected_speaker: Optional[str] = None,
    ):
        """
        Adds an expected speech or command to the expected order. This does not add an actual speech -- it just tells
        the debater to expect a speech or command at a given point.

        Params:
            speech_type: The type of speech or command that is to be expected at this point.
            prompt_tag: If it is a command, this is the prompt tag corresponding to the command that is to be delivered at
                this point in the structure
            last_only_prompt_tag: If the prompt tag differs depending on if this is the last command the debater will hear
                before their next generation, then this is the tag they will use (defaults to prompt tag). An example is if
                the debater hears a command like "Please generate a speech..." before actually writing their speech, one might
                want this to show up in a transcript in the past tense like "This is the speech you gave" after one gives the
                speech.
            expected_speaker: The name of the speaker who is to deliver the speech.
        """
        speech_type = speech_type if speech_type else (SpeechType.PRE_FILLED if prompt_tag else SpeechType.USER_INPUTTED)
        self.progression.append(
            SpeechFormatEntry(
                speech_type=speech_type,
                prompt_tag=prompt_tag,
                last_only_prompt_tag=last_only_prompt_tag,
                expected_speaker=expected_speaker,
            )
        )
        return self

    def add_user_inputted_speech(self, expected_speaker: Optional[str] = None):
        """Adds a speech to the structure that is generated by an agent (debater or judge)"""
        return self.add(
            speech_type=SpeechType.USER_INPUTTED,
            prompt_tag=None,
            expected_speaker=expected_speaker if expected_speaker else self.name,
        )

    def add_format(self, speech_format: SpeechFormat, repeats: num_repetitions = 1):
        """Merges another speech format into this one"""
        for i in range(repeats):
            for speech_type, prompt_tag, last_only_prompt_tag, expected_speaker in speech_format:
                self.add(
                    speech_type=speech_type,
                    prompt_tag=prompt_tag,
                    last_only_prompt_tag=last_only_prompt_tag,
                    expected_speaker=expected_speaker,
                )
        return self

    def __iter__(self):
        self.idx = 0
        return self

    def __next__(self):
        if self.idx < len(self.progression):
            entry = self.progression[self.idx]
            self.idx += 1
            return entry.speech_type, entry.prompt_tag, entry.last_only_prompt_tag, entry.expected_speaker
        else:
            raise StopIteration


class Transcript:
    def __init__(
        self,
        name: str,
        prompt: Prompt,
        speech_format: SpeechFormat,
        index: int = 0,
    ):
        """
        An abstraction that tracks the commands and speeches delivered in the round. This can then
        be used to construct an input to a model.

        Params:
            name: The name of the debater who is to use this transcript.
            prompt: The prompt that is used to generate commands.
            speech_format: The order of speeches and commands that the debater expects to receive.
            index: The index corresponding to which element in the batch this transcript is being used for.
        """
        self.prompt = prompt
        self.name = name
        self.speeches = []
        self.speech_format = speech_format

    def reset(self) -> None:
        """Removes all the given speeches"""
        self.speeches = []

    def add_speech(self, speaker: str, content: str) -> None:
        """Adds an agent-generated speech to the transcript"""
        self.speeches.append(Speech(speaker=speaker, content=content))

    def save(self, save_file_path_prefix: str, metadata: Optional[dict[Any, Any]]) -> None:
        """Saves to the specified path"""
        with open(save_file_path_prefix + ".txt", "w") as f:
            f.write(str(self.full_string_value()))
        with open(save_file_path_prefix + ".json", "w") as f:
            json.dump(self.json_value(metadata=metadata), f)

    def to_model_input(self) -> list[ModelInput]:
        """Converts the speech to a list of inputs that can be used to generate more text by models"""

        def add_to_model_inputs(model_inputs: list[ModelInput], new_addition: ModelInput) -> None:
            if model_inputs and model_inputs[-1].role == new_addition.role:
                model_inputs[-1] = ModelInput(
                    role=new_addition.role, content=f"{model_inputs[-1].content}\n\n{new_addition.content}"
                )
            else:
                model_inputs.append(new_addition)

        model_inputs = []
        index = 0
        for i, (speech_type, prompt_tag, last_only_prompt_tag, expected_speaker) in enumerate(self.speech_format):
            if speech_type == SpeechType.PRE_FILLED:
                prompt_tag_to_use = (
                    prompt_tag if (index < len(self.speeches) or not last_only_prompt_tag) else last_only_prompt_tag
                )

                add_to_model_inputs(
                    model_inputs,
                    ModelInput(
                        role=RoleType.SYSTEM if i < 2 else RoleType.USER,
                        content=self.prompt.messages[prompt_tag_to_use].content[
                            index % len(self.prompt.messages[prompt_tag_to_use].content)
                        ],
                    ),
                )
            else:
                if index >= len(self.speeches):
                    break
                role = RoleType.USER if self.speeches[index].speaker != self.name else RoleType.ASSISTANT
                add_to_model_inputs(model_inputs, ModelInput(role=role, content=self.speeches[index].content))
                index += 1

        return model_inputs

    def get_last_external_speech(self) -> Optional[str]:
        """Get the text of the last speech that was delivered by a different agent"""
        for i in range(len(self.speeches)):
            speech = self.speeches[len(self.speeches) - i - 1]
            if speech.speaker != self.name:
                return speech
        return ""

    def get_next_expected_speaker(self) -> Optional[str]:
        """Gets the name of the next agent that is expected to deliver a speech"""
        expected_speakers = [expected_speaker for _, _, _, expected_speaker in filter(lambda x: x[-1], self.speech_format)]
        expected_speaker = expected_speakers[len(self.speeches)] if len(self.speeches) < len(expected_speakers) else None
        return expected_speaker

    def only_decision_remains(self) -> bool:
        """Returns true if there are no more speeches that are expected to be delivered besides the
        judge's final verdict"""
        expected_speakers = [expected_speaker for _, _, _, expected_speaker in filter(lambda x: x[-1], self.speech_format)]
        remaining_speakers = (
            set(expected_speakers[len(self.speeches) :]) if len(self.speeches) < len(expected_speakers) else set()
        )
        return constants.DEFAULT_JUDGE_NAME in remaining_speakers and len(remaining_speakers) == 1

    def full_string_value(self) -> str:
        """Converts the transcript into a string for logging and saving"""
        return "\n\n".join([x.content for x in self.to_model_input()])

    def json_value(self, metadata: Optional[dict[Any, Any]] = None) -> str:
        """Converts the transcript into a json object that can be parsed for offline processing"""
        speeches = []
        index = 0
        for i, (speech_type, prompt_tag, _, expected_speaker) in enumerate(self.speech_format):
            if speech_type == SpeechType.PRE_FILLED:
                content = self.prompt.messages[prompt_tag].content[index % len(self.prompt.messages[prompt_tag].content)]
            else:
                if index >= len(self.speeches):
                    break
                content = self.speeches[index].content
                index += 1
            speeches.append(
                Speech(
                    speaker=expected_speaker or "Prompt",
                    content=content,
                ).dict()
            )

        return {"metadata": metadata, "speeches": speeches}

    def copy(self) -> Transcript:
        """Deepcopies this objects"""
        return copy.deepcopy(self)

    def truncate(self, idx: int, debaters_only: bool = False) -> None:
        """
        Removes all the speeches after the specified index.

        Params:
            idx: The last speech in the round to include before removing the rest
            debaters_only: whether the idx refers to only speeches given by the debaters
        """
        max_idx = len(self.speeches)
        if debaters_only:
            counter = 0
            max_idx = 0
            idx_to_true_idx = {}
            for i, speech in enumerate(self.speeches):
                if speech.speaker != constants.DEFAULT_JUDGE_NAME:
                    idx_to_true_idx[counter] = i
                    max_idx = counter
                    counter += 1
            idx = idx_to_true_idx[idx]
        return self.speeches[: min(idx, max_idx)]

    def get_speech_count(self, debaters_only: bool = False) -> int:
        """Returns the number of speeches that have already been added (only includes speeches by debaters
        if the debaters_only parameter is true)"""
        if not debaters_only:
            return len(self.speeches)
        else:
            return len([speech for speech in filter(lambda x: x.speaker != constants.DEFAULT_JUDGE_NAME, self.speeches)])

    def __str__(self):
        """Shorter string representation as compared to full_string_value()"""
        return f"Name: {self.name}\n\n" + "\n\n".join([str(speech) for speech in self.speeches])
